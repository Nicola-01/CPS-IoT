import threading
from Crypto.PublicKey import ECC
from crypto_utils import *

class IoTServer(threading.Thread):
    """
    IoT Server class that handles authentication requests from IoT devices.
    Uses ECC for secure communication and mutual authentication.
    """
    def __init__(self):
        """
        Initializes the IoT server.
        Generates an ECC key pair and sets up a lock for thread-safe operations.
        """
        super().__init__()
        self.key = ECC.generate(curve='secp256r1')  # Generate ECC key using the secp256r1 curve
        self.public_key = self.key.public_key()  # Extract the public key
        self.__authRequests = []  # List to store authentication requests
        self.lock = threading.Lock()  # Lock for thread-safe operations

    def getPublicKey(self):
        """Return the server's public key."""
        return self.public_key

    def setUpConnection(self, deviceID, deviceNonce, devicePublicKey):
        """
        Insert authentication data into __authRequests for a specific deviceID.
        
        Args:
            deviceID (int): The ID of the IoT device.
            deviceNonce (bytes): The nonce generated by the device.
            devicePublicKey (ECC.EccKey): The public key of the device.
        
        Returns:
            bytes: The server's nonce for the device.
        """
        with self.lock:
            serverNonce = generateNonce()  # Generate a nonce for the server
            self.__authRequests.append({
                'deviceID': deviceID,
                'serverNonce': serverNonce,
                'deviceNonce': deviceNonce,
                'devicePublicKey': devicePublicKey
            })
            return serverNonce

    def startAuthentication(self, deviceID, device_signature):
        """
        Verify the device's signature and sign the device's nonce for mutual authentication.
        
        Args:
            deviceID (int): The ID of the IoT device.
            device_signature (bytes): The signature of the server's nonce by the device.
        
        Returns:
            bytes: The server's signature of the device's nonce, or None if verification fails.
        """
        with self.lock:
            found = False
            for authData in self.__authRequests:
                if authData['deviceID'] == deviceID:
                    found = True
                    break
            if not found:
                return None

            authData = self.__authRequests.pop(0)  # Retrieve and remove the authentication data
            serverNonce = authData['serverNonce']
            deviceNonce = authData['deviceNonce']
            devicePublicKey = authData['devicePublicKey']

        # Verify the device's signature on the server's nonce      
        if not verifySignature(devicePublicKey, serverNonce, device_signature):
            return None

        # Sign the device's nonce and return the signature
        return signData(self.key, deviceNonce)

    def run(self):
        """Main server loop. No active processing needed in this example."""
        pass